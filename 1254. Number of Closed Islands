class Solution:
    def closedIsland(self, grid: List[List[int]]) -> int:
        visited = set()
        closed_island = 0
        m = len(grid)
        n = len(grid[0])

        if not grid:
            return

        def dfs(r,c):
            if r<0 or r>=m or c<0 or c>=n:
                return False
            if grid[r][c] == 1:
                return True
            if (r,c) in visited:
                return True
            if r==0 or r==m-1 or c==0 or c==n-1:
                return False
            visited.add((r,c))
            
            right = dfs(r, c+1)
            left = dfs(r, c-1)
            down = dfs(r+1, c)
            up = dfs(r-1, c)

            return up and down and right and left

        for r in range(m):
            for c in range(n):
                if grid[r][c] == 0 and (r,c) not in visited:
                    if dfs(r,c):
                        closed_island += 1
                    
        return closed_island

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

// without visited or extra space

class Solution:
    def closedIsland(self, grid: List[List[int]]) -> int:
        if not grid:
            return 0
        
        m, n = len(grid), len(grid[0])
        
        def dfs(r, c):
            # Out of bounds → open island
            if r < 0 or r >= m or c < 0 or c >= n:
                return False
            
            # Water → safe
            if grid[r][c] == 1:
                return True
            
            # Boundary land → open
            if r == 0 or r == m-1 or c == 0 or c == n-1:
                grid[r][c] = 1
                return False
            
            # Mark visited
            grid[r][c] = 1
            
            up = dfs(r-1, c)
            down = dfs(r+1, c)
            left = dfs(r, c-1)
            right = dfs(r, c+1)
            
            return up and down and left and right
        
        count = 0
        
        for r in range(m):
            for c in range(n):
                if grid[r][c] == 0:
                    if dfs(r, c):
                        count += 1
        
        return count
